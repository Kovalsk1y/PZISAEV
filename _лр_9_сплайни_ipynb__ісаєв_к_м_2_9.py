# -*- coding: utf-8 -*-
""""ЛР_9_Сплайни.ipynb" Ісаєв К.М 2-9

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YONvjXpXzjy-gXv3HILZGyFddqp5RECn

**Лабораторна робота 8. Сплайни**
"""

import numpy as np
from scipy.interpolate import CubicSpline
import matplotlib.pyplot as plt

"""#Варіант 1.
**Побудова кубічного сплайну.**
"""

# Дані (варіант 8)
x = np.array([0.8, 1.0, 1.3, 1.9, 2.3])
y = np.array([1.72, 2.35, 1.52, 2.43, 1.55])

n = len(x) - 1
h = np.diff(x)
a = y.copy()
b = np.zeros(n)
d = np.zeros(n)
c = np.zeros(n + 1)    # c[0..n]

alpha = np.zeros(n + 1)
for i in range(1, n):
    alpha[i] = (3 / h[i]) * (a[i+1] - a[i]) - (3 / h[i-1]) * (a[i] - a[i-1])

l = np.ones(n + 1)
mu = np.zeros(n + 1)
z = np.zeros(n + 1)

# Пряма хода
for i in range(1, n):
    l[i] = 2 * (x[i+1] - x[i-1]) - h[i-1] * mu[i-1]
    mu[i] = h[i] / l[i]
    z[i] = (alpha[i] - h[i-1] * z[i-1]) / l[i]

# Крайові умови (натуральний сплайн)
l[n] = 1
z[n] = 0
c[n] = 0

# Зворотний хід
for j in range(n-1, -1, -1):
    c[j] = z[j] - mu[j] * c[j+1]
    b[j] = (a[j+1] - a[j]) / h[j] - h[j] * (c[j+1] + 2*c[j]) / 3
    d[j] = (c[j+1] - c[j]) / (3 * h[j])

# Вивід коефіцієнтів
for i in range(n):
    print(f"Інтервал [{x[i]}, {x[i+1]}]:")
    print(f" a = {a[i]:.6f}")
    print(f" b = {b[i]:.6f}")
    print(f" c = {c[i]:.6f}")
    print(f" d = {d[i]:.6f}")
    print("-"*40)

x = np.array([0.8, 1.0, 1.3, 1.9, 2.3])
y = np.array([1.72, 2.35, 1.52, 2.43, 1.55])

# Щоб бути незалежним, повторимо обчислення коефіцієнтів
n = len(x) - 1
h = np.diff(x)
a = y.copy()
b = np.zeros(n)
d = np.zeros(n)
c = np.zeros(n + 1)

alpha = np.zeros(n + 1)
for i in range(1, n):
    alpha[i] = (3 / h[i]) * (a[i+1] - a[i]) - (3 / h[i-1]) * (a[i] - a[i-1])

l = np.ones(n + 1)
mu = np.zeros(n + 1)
z = np.zeros(n + 1)

for i in range(1, n):
    l[i] = 2 * (x[i+1] - x[i-1]) - h[i-1] * mu[i-1]
    mu[i] = h[i] / l[i]
    z[i] = (alpha[i] - h[i-1] * z[i-1]) / l[i]

l[n] = 1
z[n] = 0
c[n] = 0

for j in range(n-1, -1, -1):
    c[j] = z[j] - mu[j] * c[j+1]
    b[j] = (a[j+1] - a[j]) / h[j] - h[j] * (c[j+1] + 2*c[j]) / 3
    d[j] = (c[j+1] - c[j]) / (3 * h[j])

# Побудова гладкої кривої зі сплайна
x_values = np.linspace(x[0], x[-1], 400)
y_values = []

for xi in x_values:
    # знайти інтервал
    for i in range(n):
        if x[i] <= xi <= x[i+1] or (i == n-1 and xi == x[-1]):
            dx = xi - x[i]
            yi = a[i] + b[i]*dx + c[i]*dx**2 + d[i]*dx**3
            y_values.append(yi)
            break

plt.figure(figsize=(8,5))
plt.plot(x_values, y_values, label='Кубічний сплайн (власний)', linewidth=2)
plt.scatter(x, y, color='red', label='Вузлові точки')
plt.xlabel('x')
plt.ylabel('y')
plt.title('Кубічний сплайн (вручну)')
plt.legend()
plt.grid(True)
plt.show()

"""#Варіант 2
**Перевірка за допомогою методу CubicSpline**
"""

import numpy as np
from scipy.interpolate import CubicSpline

# Дані (варіант 8)
x = np.array([0.8, 1.0, 1.3, 1.9, 2.3])
y = np.array([1.72, 2.35, 1.52, 2.43, 1.55])

# Створюємо CubicSpline (натуральні крайові, by default 'not-a-knot'; вкажемо bc_type='natural' для натурального)
cs = CubicSpline(x, y, bc_type='natural')

# Вивід коефіцієнтів для кожного інтервалу
# cs.c має форму (4, n_intervals): [a3; a2; a1; a0] для кожного інтервалу, де S(x) = a3*(x - x_i)^3 + a2*(x - x_i)^2 + a1*(x - x_i) + a0
for i in range(len(x)-1):
    coeffs = cs.c[:, i]
    print(f"S_{i+1}(x) on [{x[i]}, {x[i+1]}]:")
    print(f"  {coeffs[0]:.6f}*(x - {x[i]:.3f})^3 + {coeffs[1]:.6f}*(x - {x[i]:.3f})^2 + {coeffs[2]:.6f}*(x - {x[i]:.3f}) + {coeffs[3]:.6f}")
    print("-"*60)

# Побудова кубічного сплайну
cs = CubicSpline(x, y, bc_type='natural')

# Нові точки для гладкої кривої
x_new = np.linspace(x[0], x[-1], 400)
y_new = cs(x_new)

plt.figure(figsize=(8,5))
plt.plot(x_new, y_new, label='CubicSpline (scipy)', linewidth=2)
plt.scatter(x, y, color='red', label='Вузлові точки')
plt.xlabel('x')
plt.ylabel('y')
plt.title('Перевірка: CubicSpline (scipy)')
plt.legend()
plt.grid(True)
plt.show()

"""#Варіант 3. Побудова сплайну


"""

# Функція-реалізація Гаусса (для квадратної матриці)
def gauss(A, b):
    A = [row[:] for row in A]  # копії, щоб не змінювати вхідні списки
    b = b[:]
    n = len(b)
    for i in range(n):
        # частковий вибір головного елемента
        max_row = max(range(i, n), key=lambda r: abs(A[r][i]))
        A[i], A[max_row] = A[max_row], A[i]
        b[i], b[max_row] = b[max_row], b[i]
        # виключення
        for j in range(i+1, n):
            if abs(A[i][i]) < 1e-12:
                continue
            factor = A[j][i] / A[i][i]
            b[j] -= factor * b[i]
            for k in range(i, n):
                A[j][k] -= factor * A[i][k]
    # зворотній хід
    x = [0]*n
    for i in range(n-1, -1, -1):
        s = sum(A[i][j]*x[j] for j in range(i+1, n))
        x[i] = (b[i] - s) / A[i][i]
    return x

# Побудова системи для сплайнів (невеликий приклад — освітній)
# Тут формування А та b для загальної системи досить довге; нижче — просто тест запуску Гаусса на малій системі
A = [
    [2.0, 1.0, 0.0],
    [1.0, 2.0, 1.0],
    [0.0, 1.0, 2.0]
]
b = [1.0, 2.0, 3.0]

x_sol = gauss(A, b)
print("Приклад рішення системи методом Гаусса (тест):", x_sol)