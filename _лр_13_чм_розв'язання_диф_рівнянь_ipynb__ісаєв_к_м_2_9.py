# -*- coding: utf-8 -*-
""""ЛР_13_ЧМ_Розв'язання диф. рівнянь.ipynb" Ісаєв К.М 2-9

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NX63iWoKQ7HTAY7aCLqXMTtbzuh_E6wv

Лабораторна робота 13.

#Метод Ейлера
"""

import numpy as np
import matplotlib.pyplot as plt

def f(x, y):
    return x + np.cos(y / 2)

# Параметри
a, b, h, y0 = 0.8, 1.8, 0.1, 1.4

# Перевірка вхідних параметрів
if h <= 0:
    print("Крок h повинен бути позитивним.")
    exit()
if a >= b:
    print("Права межа b повинна бути більшою за ліву межу a.")
    exit()

n = int((b - a) / h)          # кількість кроків
x = np.array([a + i*h for i in range(n + 1)])  # вузли x

y = np.empty(n + 1)
y[0] = y0

# Метод Ейлера
for i in range(n):
    y[i + 1] = y[i] + f(x[i], y[i]) * h

# Округлення для NumPy 2.0+
y_rounded = np.round(y, 4)

print("x =", x)
print("y =", y_rounded)

plt.plot(x, y, "o", x, y, "red")
plt.xlabel("x")
plt.ylabel("y")
plt.title("Метод Ейлера (y' = x + cos(y/2))")
plt.legend(["точки", "графік"])
plt.grid()
plt.show()

#Додати перевірку odeint для першого завдання

#додати перевірку solve_ivp для перешого завдання

"""#Метод Ейлера-Коші"""

import numpy as np
import matplotlib.pyplot as plt

def f(x, y):
    return x + np.cos(y / 2)

# Параметри
a = 0.8
b = 1.8
h = 0.1
y0 = 1.4

n = int((b - a) / h)
x = np.arange(a, b + h, h)

y = np.empty(n + 1)
y[0] = y0

# Метод Ейлера–Коші
for i in range(n):
    k1 = f(x[i], y[i])
    k2 = f(x[i] + h, y[i] + h * k1)
    y[i + 1] = y[i] + h * (k1 + k2) / 2

y_rounded = np.round(y, 4)

print("x =", x)
print("y =", y_rounded)

plt.plot(x, y, "o", x, y, "red")
plt.xlabel("x")
plt.ylabel("y")
plt.title("Метод Ейлера–Коші (y' = x + cos(y/2))")
plt.legend(["точки", "графік"])
plt.grid()
plt.show()

"""#Розв’язок диф. Рівняння за допомогою scipy.integrate import odeint"""

import numpy as np
from scipy.integrate import odeint
import matplotlib.pyplot as plt

# dy/dx
def model(y, x):
    return x + np.cos(y / 2)

# Початкова умова
y0 = 1.4

# x з кроком 0.1 на відрізку [0.8; 1.8]
x = np.arange(0.8, 1.8 + 0.1, 0.1)

# Розв'язання ODE
y = odeint(model, y0, x)

# Округлення NumPy 2.0
y_round = np.round(y.flatten(), 4)

print("x =", x)
print("y =", y_round)

plt.plot(x, y_round, marker='o')
plt.xlabel("x")
plt.ylabel("y(x)")
plt.title("ODEINT розв'язання (y' = x + cos(y/2))")
plt.grid()
plt.show()

"""#Використання scipy.integrate.solve_ivp
Функція solve_ivp є більш сучасним і гнучким способом розв'язання ODE, ніж odeint. Вона також дозволяє використовувати різні методи інтегрування.
"""

import numpy as np
from scipy.integrate import solve_ivp
import matplotlib.pyplot as plt

# dy/dx
def model(x, y):
    return x + np.cos(y / 2)

# Початкова умова
y0 = [1.4]

# x точки
x_eval = np.arange(0.8, 1.8 + 0.1, 0.1)

# Розв'язання
sol = solve_ivp(model, [0.8, 1.8], y0, t_eval=x_eval)

y_round = np.round(sol.y[0], 4)

print("x =", sol.t)
print("y =", y_round)

plt.plot(sol.t, y_round, marker='o')
plt.xlabel("x")
plt.ylabel("y(x)")
plt.title("solve_ivp (y' = x + cos(y/2))")
plt.grid()
plt.show()