# -*- coding: utf-8 -*-
"""Ісаєв К лабороторна 2 Варіант 8

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1p0rQBaB8cqbYC4qUG85RKIX7QJiMmkJN

Ісаєв Кирило Варіант 8 Лабороторна №3




```
# Має бути у форматі коду
```

1. Метод ділення навпіл.
"""

import numpy as np
import pandas as pd

# Визначаємо функцію
def f (x):
    y = np.cos(x)*np.sin(x)*(x**2+x+1)
    return y
# Визначаємо границі відрізку
a, b = -3, -1
# Визначаємо точність розв'язку
eps = 0.001
# Поділяємо відрізок навпіл
c = (a+b)/2
# Зберігаємо результати обчислень
data_A = [a]
data_B = [b]
data_C = [c]
data_F_A = [f(a)]
data_F_B = [f(b)]
data_F_C = [f(c)]
# Перевіряємо досягнення точності
while np.abs(f(c)) > eps:
    # Звужуємо відрізок
    if np.sign(f(c)) == np.sign(f(a)):
        a = c
    else:
        b = c
    # Поділяємо відрізок навпіл
    c = (a+b)/2
    # Зберігаємо результати обчислень
    data_A.append(a)
    data_B.append(b)
    data_C.append(c)
    data_F_A.append(f(a))
    data_F_B.append(f(b))
    data_F_C.append(f(c))
# Відображаємо результати обчислень
print('Результати обчислень')
print()
data = pd.DataFrame({'a': data_A,
                     'F(a)': data_F_A,
                     'c': data_C,
                     'F(c)': data_F_C,
                     'b': data_B,
                     'F(b)': data_F_B})
print(data)
# Відображаємо наближений корінь рівняння
print()
print('В точці с = ', c, ', f(c) = ', f(c))

"""2. Метод ділення навпіл"""

import numpy as np
import scipy.optimize as sp

def f(x):
    y = np.cos(x)*np.sin(x)*(x**2+x+1)
    return y

a, b = -3, -1
eps = 1.e-3

x = sp.bisect(f, a, b,(),eps) #функція для метода

print('The approximate solution x is:', x)
print('And the value f(x) is:', f(x))

"""3. Метод хорд"""

import numpy as np
import pandas as pd
# Визначаємо функцію
def f(x):
    y = np.cos(x)*np.sin(x)*(x**2+x+1)
    return y
# Визначаємо межі відрізку
a, b = -3, -1
# Визначаємо точність розв'язку
eps = 0.001
# Точка, де хорда перетинає вісь 0x
c = (f(a)*b-a*f(b))/(f(a)-f(b))

# Зберігаємо результати обчислень
data_A = [a]
data_B = [b]
data_C = [c]
data_F_A = [f(a)]
data_F_B = [f(b)]
data_F_C = [f(c)]
# Перевіряємо досягнення точності
while np.abs(f(c)) > eps:
    # Звужуємо відрізок
    if np.sign(f(c)) == np.sign(f(a)):
        a = c
    else:
        b = c
    # Точка, де хорда перетинає вісь 0x
    c = (f(a)*b-a*f(b))/(f(a)-f(b))
    # Зберігаємо результати обчислень
    data_A.append(a)
    data_B.append(b)
    data_C.append(c)
    data_F_A.append(f(a))
    data_F_B.append(f(b))
    data_F_C.append(f(c))
# Відображаємо результати обчислень
print('Результати обчислень')
print()
data = pd.DataFrame({'a': data_A, 'F(a)': data_F_A,
                     'c': data_C, 'F(c)': data_F_C,
                     'b': data_B, 'F(b)': data_F_B})
print(data)
# Відображаємо наближений корінь рівняння
print()
print('В точці с = ', c, ', f(c) = ', f(c))

"""4. Метод Ньютона (дотичних)"""

import numpy as np
import pandas as pd
# Визначаємо функцію
def f(x):
    y = np.cos(x)*np.sin(x)*(x**2+x+1)
    return y
# Визначаємо першу похідну
def df(x):
    y1 = -(x**2+x+1)*(np.sin(x))**2
    y2 = (x**2+x+1)*(np.cos(x))**2
    y3 = (2*x+1)*np.sin(x)*np.cos(x)
    y = y1+y2+y3
    return y
# Визначаємо початкову точку
c = -1.4
# Визначаємо точність розв'язку
h = 0.001
# Зберігаємо результати обчислень
data_C = [c]
data_F_C = [f(c)]
# Перевіряємо досягнення точності
while abs(f(c)) > h:
    # Точка, де дотична перетинає вісь 0x
    c -= f(c)/df(c)
    # Зберігаємо результати обчислень
    data_C.append(c)
    data_F_C.append(f(c))
# Відображаємо результати обчислень
print('Результати обчислень')
print()
data = pd.DataFrame({'c': data_C, 'F(c)': data_F_C})
print(data)
# Відображаємо наближений корінь рівняння
print()
print('В точці с = ', c, ', f(c) = ', f(c))

"""5. Метод Ньютона (дотичних)"""

import numpy as np
import scipy.optimize as sp

def f(x):
    y = np.cos(x)*np.sin(x)*(x**2+x+1)
    return y

def df(x):# Обчислення похідної
    y1 = -(x**2+x+1)*(np.sin(x))**2
    y2 = (x**2+x+1)*(np.cos(x))**2
    y3 = (2*x+1)*np.sin(x)*np.cos(x)
    y = y1+y2+y3
    return y

x0 = -1.4
x1 = 1.4

x_0 = sp.newton(f, x0, df, tol=1.e-3, maxiter=50)
x_1 = sp.newton(f, x1, df, tol=1.e-3, maxiter=50)

print('The approximate solution x is:', x_0)
print('And the value f(x_0) is:', f(x_0))

print('The approximate solution x is:', x_1)
print('And the value f(x_0) is:', f(x_1))

""" # Знаходження коренів рівняння за допомогою бібліотеки SymPy"""

import sympy as sym

x = sym.Symbol('x')

y = sym.cos(x)*sym.sin(x)*(x**2+x+1)

s = sym.solve(y)

print(s)

import sympy as sym

x, a, b, c = sym.symbols('x, a, b, c')

y = a * x**2 + b * x + c

s = sym.solve(y, x)

print(s)

!pip install numdifftools

#Лабораторна робота 2
#Відокремлення коренів
import numpy as np
import numdifftools as nd

def f(x):
    return  6*x**4 + 8*x**3 - 24*x**2-7


def find_segments(): #відокремлюємо корені
    search_range = np.arange(-10, 1, 1)

    a = None
    previous_x = None
    current_x  = None
    segments = []

    for x in search_range:
        x = round(x, 4)
        current_x = f(x)
        if previous_x != None and previous_x * current_x < 0:
            segments.append((a, x))
        a = x
        previous_x = current_x
    return segments

segments = find_segments()
for a, b in segments:
    print(f'Found segment:  [{a}, {b}]')

import numpy as np
import matplotlib.pyplot as plt

# Визначення функції
def f(x):
    return 6*x**4 + 8*x**3 - 24*x**2-7

# Генерація значень x
x = np.linspace(-3, 3, 100)

# Генерація значень y
y = f(x)

# Побудова графіка
plt.figure(figsize=(8, 6))
plt.plot(x, y, label='9*x^4 + 8*x^3 + 1.5*x^2 + 2*x - 10', color='blue')
plt.title('Графік функції 9*x^4 + 8*x^3 + 1.5*x^2 + 2*x - 10')
plt.xlabel('x')
plt.ylabel('f(x)')

# Додавання осей з стрілками
plt.axhline(0, color='black', linewidth=0.5)
plt.axvline(0, color='black', linewidth=0.5)

plt.text(2.05, -4, 'x', ha='center', va='center')
plt.text(-0.3, 190, 'y', ha='center', va='center')

plt.grid(True)
plt.legend()
plt.show()

"""![image.png](data:image/png;base64,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)"""

#Лабораторна робота. Метод половинного ділення, хорд

def rec(a, b, eps):  # метод половинного ділення
    while (np.abs(a - b) > eps):
        if f(a) * f((a + b) / 2) < 0:
            b = (a + b) / 2
        else:
            a = (a + b) / 2
        x = (a + b) / 2

    print('x= ', round(x, 5), '  -   Half division method')

if __name__ == "__main__":
    a1, b1 = -10, -1
    a2, b2 = 0, 1
    eps = 0.0001
    print("Розв'язки на відрізку [-10,-1]")
    rec(a1, b1, eps)
    hord(a1, b1, eps)
    print("\n Розв'язки на відрізку [0,1]")
    rec(a2, b2, eps)
    hord(a2, b2, eps)

def hord(a, b, eps):  # метод хорд
    derivative_f = nd.Derivative(f, n=2)
    if f(a) * derivative_f(a) > 0:
        x0 = a
        xi = b
    else:
        x0 = b
        xi = a
    xi_1 = xi - (xi - x0) * f(xi) / (f(xi) - f(x0))
    while (np.abs(xi_1 - xi) > eps):
        xi = xi_1
        xi_1 = xi - (xi - x0) * f(xi) / (f(xi) - f(x0))
    print('x= ', round(xi_1, 5), '  -   Chord method')